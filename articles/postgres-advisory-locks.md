---
title: "排他制御のためだけに Redis 渋々使ってませんか？ Postgres 単独でアドバイザリーロックできるよ！"
emoji: "🔒"
type: "tech"
topics: ["postgresql", "postgres", "sql", "database", "redis"]
published: false
---

# 背景

以前， Qiita で以下の記事を投稿した。今回の議題に直接的な関係はないが，関連している部分があるため引用する。

https://qiita.com/mpyw/items/14925c499b689a0cbc59

> MySQL/Postgres とも，
>
> - MVCC アーキテクチャの恩恵で， `SELECT` と `UPDATE` は基本的には競合しない。
> - **単一レコードのシンプルな `UPDATE` でも排他ロックされ**，排他ロック中のレコードへの `UPDATE` での変更操作は **トランザクション分離レベルによらず** ブロックされる。**`UPDATE` 文に含まれる `WHERE` 句での検索もブロックされ**，これはブロックされない `SELECT` による検索とは別扱いになる。
> - **但し `UPDATE` 文の `WHERE` 句上で，更新対象をサブクエリの `SELECT` から自己参照している場合は例外。トランザクション分離レベルを `REPEATABLE READ` 以上にして，競合エラーからの復帰処理を書かなければならない。**
>
> Postgres に関しては，
>
> - `REPEATABLE READ` 以上では， MySQL よりも積極的・予防的に競合エラーを起こすようになっている。上記のように `WHERE` 句に含まれるサブクエリの `SELECT` から自己参照が発生しない場合， **`READ COMMITTED`** にしておくのが最適解。

両データベースとも，書き込み処理競合時， `REPEATABLE READ` ではデッドロックを含むエラーが発生する前提の設計になっており，リトライすることが求められる。一方で，

https://zenn.dev/shuntagami/articles/ea44a20911b817

> 分離レベルを下げ、ギャップロックを無効化することでデッドロックを回避できたものの、 `SELECT...FOR UPDATE` 句の取得結果が `NULL` であった場合にロックがかけられない（ロックする行がない）

とあるように， 更新時は `READ COMMITTED` でロッキングリードしておくことで対応できるものの， **新規作成時には（先行者のコミット完了まで）ロックする行が存在しない** ことで後続者が素通りしてしまう問題がある。

そこで，新規作成を考慮しなければならない操作対象のリソースの代わりに，存在が保証されている別のリソースをロックするルールにしよう，という戦略を取ることができる。これは **アドバイザリーロック（勧告的ロック）** と呼ばれている。

# アドバイザリーロックの実装手段

引用した記事では， `users` というユーザ情報を格納する汎用的なテーブルをアドバイザリーロックのために使用していた。ところがコメント欄でも指摘があるように，汎用的なテーブルをアドバイザリーロックに流用すると，アプリケーション実装者の

*「とりあえず `users` テーブルをロックしておこう！」*

という愚行により， **「特定ユーザに関連してはいるものの内容的には全く関係のない処理」を無駄に待機させてしまう** ことが起こるかもしれない。そのため，以下のような対応を取らなければならない。

- 特定処理専用のアドバイザリーロック用テーブルを予め作っておく
- 新規作成してもアドバイザリーロックできる何らかの手段を使う

また，アドバイザリーロックのライフサイクルとして，以下の 2 つの場合があり得る。

- 1 回のセッション・トランザクション内で完結する場合
- 複数のセッション・トランザクション上にまたがる場合

これらに着目しながら，各方式を検討していく。

## Postgres 組み込みのアドバイザリーロック関数

| 観点           | 要求を満たすか |
|:-------------|:-------:|
| 事前準備が不要      |    ✅    |
| セッションを超えたロック |    ❌    |
| 耐障害性         |    ✅    |
| クライアントの分散    |    ✅    |

これが今回最もおすすめしたい方法。

https://www.postgresql.jp/document/13/html/functions-admin.html#FUNCTIONS-ADVISORY-LOCKS

| 関数                              | ロックのスコープ  | 競合時の挙動  |
|:--------------------------------|:---------:|:-------:|
| `pg_advisory_lock`              |   セッション   |   待機    |
| `pg_try_advisory_lock`          |   セッション   |   待機    |
| `pg_advisory_xact_lock`         | トランザクション  |   失敗    |
| **`pg_try_advisory_xact_lock`** | トランザクション  |   失敗    |

以下の理由から，最後の **`pg_try_advisory_xact_lock`** が最も使い勝手がよいと考えられる。

- トランザクションがコミットまたはロールバックされて消滅したとき，自動的にロックが解放されるのはありがたい。
- ロックを待機し続けるよりも，ロックに失敗したときに潔く諦めてエラーを返すほうが負荷がかかりにくい。

:::message alert
PHP のように，データベースコネクションを使い捨てにする動作方式が一般的である言語の場合は全て安全に取り扱えるが，その他の多くの言語は **HTTP リクエストの処理が終わってもコネクションを別ユーザのために再利用する** ことが一般的になっている。そのため，ロックのスコープはトランザクションの範囲にしておいたほうが安全ではあるだろう。
:::

ところで，関数のシグネチャは以下のようになっている。

```java
pg_try_advisory_xact_lock(key bigint): boolean
pg_try_advisory_xact_lock(key1 integer, key2 integer): boolean
```

*「あれ…文字列渡したいんだけど…？」*

文字列を受け取るようにし， Postgres 側がハッシュ化した値をキーにして管理してくれてもいいような気はするが，最小限と割り切ってこのような実装になっているのだろうか？

https://stackoverflow.com/questions/29353845/how-do-i-use-string-as-a-key-to-postgresql-advisory-lock

こちらの回答に従って， 2 つの使い方を示す。

```sql
SELECT pg_try_advisory_xact_lock(hashtext('任意の文字列'));
SELECT pg_try_advisory_xact_lock('テーブル名'::regclass::integer, 識別子の整数);
```

- **`hashtext()`** で **任意文字列に対応する符号付き 64 ビット整数** が取得できるため，必要な情報を全て文字列内に含ませてからハッシュ化した結果を引数として取ることができる。
  - 汎用性が高いが，衝突が発生する可能性がある。しかし，衝突が発生してもロック取得に失敗する程度であるため，エラー対応処理が書かれていればさほど問題はない。 
- **`::regclass::integer`** で **テーブルに対応する一意な符号なし 32 ビット整数** が取得できるため，これをそのまま第 1 引数に取ることができる。

:::message
32 ビット整数を 2 つ取る方法のほうが **絶対に衝突が発生しない** メリットはある。しかし，主キーが 64 ビット整数や `uuid` である場合， 32 ビット整数の範囲に落とし込まないと使えない。また，KVS のように任意のキーをアプリケーション側で組み立てて取り扱いたいケースのほうが多いと考えられるので，基本的にはハッシュ値の引数を 1 つ取る方に倒しておくほうが良い。
:::

## OS のファイルロック

| 観点           | 要求を満たすか |
|:-------------|:-------:|
| 事前準備が不要      |    ✅    |
| セッションを超えたロック |    ❌    |
| 耐障害性         |    ✅    |
| クライアントの分散    |    ❌    |

## Redis

| 観点           | 要求を満たすか |
|:-------------|:-------:|
| 事前準備が不要      |    ✅    |
| セッションを超えたロック |    ❌    |
| 耐障害性         |   🔺    |
| クライアントの分散    |    ✅    |

## 特定処理専用のアドバイザリーロック用テーブル

| 観点           | 要求を満たすか |
|:-------------|:-------:|
| 事前準備が不要      |    ❌    |
| セッションを超えたロック |    ✅    |
| 耐障害性         |    ✅    |
| クライアントの分散    |    ✅    |

